В первую очередь, исходя из условия задачи, было сделано допущение, что приходят временные метки корректно или же отсортированные в порядке возрастания.
Если это не так и какие-то метки пришли с заподзданием, то можно метки просто отсортировать и общая сложность алгоритма возрастёт до линейно-логарифминчской или же O(pupil*log(pupil) + tutor*log(tutor)), линейные части при пересечении отпадут, так как оцениваем сверху.
Первое, что нужно сделать - это пересечь интервалы, для этого была создана функции intersection, которая возвращает список интервалов, сложность выполнения данной функции O(pupil + tutor), если принять во внимание пункт 1, иначе смотреть пункт 2.
Второе, так как пересечённые интервалы могли повториться, то при подсчёте один и тот же интервал был бы учтён дважды, для этого было создана функция merge, которая упаковывает такие случаии, сложность выполнения равна O(n), то есть от длины пересечённых интервалов.